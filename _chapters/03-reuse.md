---
layout: chapter
title: Повторное использование
section: Background
permalink: /chapters/reuse/
description: Почему отказ от повторного использования и принятие повторений делает работу с CSS проще.
---

**Summary:** Не пытайтесь повторно использовать стили. Воспользуйтесь duplication-first подходом.

> &ldquo;Принцип DRY часто неверно понимается как отказ от повторения одного и того же дважды [...]. Это непрактично и обычно контрпродуктивно. Это может привести к вынужденным абстракциям, к заумному и чрезмерно запроектированному коду.&ldquo;
<br>&mdash; <cite>Harry Roberts, CSS Wizardy</cite>

Поймите правильно, MaintainableCSS включает различные подходы для повторного использования, о которых речь пойдет позже. Проблемой же является повторное использование элементов, заключенных *внутри* фигурных скобок. И вот почему:

## Поскольку изменение стилей опирается на контрольные точки.

Мы создаем адаптивные сайты, меняя стили элемементов в зависимости от размера экрана. Предположим, нам нужна такая таблица из двух колонок, чтобы:

-  свойство padding составляло 50px и 20px на больших и малых экранах соответственно.
- размер шрифта составлял 3em и 2em на больших и малых экранах соответственно.
- на малых экранах колонки располагались одна под другой. Заметим, что понятие колонка в этом случае становится довольно условным.

Исходя из этого, как бы вы воспользовались следующими элементарными именами классов: `.grid`, `.col`, `.pd50`, `.pd20`, `.fs2` and `fs3`, - чтобы удовлетворить требованиям задания?

	<div class="grid">
	  <div class="col pd50 pd20 fs3 fs2">Column 1</div>
	  <div class="col pd50 pd20 fs3 fs2">Column 2</div>
	</div>

Как видите, это просто не будет работать. Теперь вам понадобятся такие странные имена классов, как `fs3large`. И это только вершина айсберга, когда дело доходит до реализации.

В качестве альтернативы рассмотрим следующую семантическую разметку, где мы не пытаемся использовать стили повторно:

	<div class="someModule">
	  <div class="someModule-someComponent"></div>
	  <div class="someModule-someOtherComponent"></div>
	</div>

Благодаря чему, реализация стилей, описанных ранее, становится простой задачей, требующей всего шесть CSS-деклараций, три из которых будут находиться в медиа-запросах.

## Поскольку изменение стилей зависит от состояния.

Как бы вы сделали, чтобы элемент `<a class="padding-left-20 red" href="#"></a>` при смене состояния на hovered, focused или active имел уже padding 18px, тонкую границу и текст более темного оттенка на сером фоне? `:hover`,`:focus`, `:active` и прочее?

Если коротко, то никак. Не создавайте себе проблемы.

## Поскольку повторное использование усложняет отладку.

Несколько CSS селекторов, примененных к элементу, добавляют помех в его отладку.

## Поскольку не стоит возиться с детализированными стилями.

Если вы собираетесь использовать `<div class="red">`, то можно также сделать `<div style="color: red">`, и такой вариант будет даже более понятным. Но мы не хотим смешивать понятия.

## Поскольку имена класса, продиктованные отображением, порой довольно неопределенны.

Например, имя `red`. Это цвет фона или текста или градиента? Какой оттенок красного оно обозначает?

## Поскольку изменения "служебного" класса влияют на все случаи его применения.

Звучит заманчиво, но на деле это не так. Вы столкнетесь с тем, что сделанные изменения повлияют и на совсем другие участки кода. Задумайтесь о регрессионных ошибках. Как вариант, вы начнете бояться прикасаться к этому классу общего пользования и создадите `.red2`. Так возникает избыточный код, поддерживать который, конечно, неприятно.

## Поскольку несемантические имена классов усложняют поиск.

Если для элемента определены классы, продиктованные внешним видом, такие как `.red`, `.col-lg-4` и `.large`, тогда такие классы будут встречаться по всему коду. Результаты поиска для "red" будут многочисленны и разбросаны по разным шаблонам HTML, что усложняет поиск интересующего элемента.

В случае семантических имен классов поиск должен выдать единственный результат. А если результатов несколько, то это свидетельствует о проблеме, требующей внимания.

Примечание: если у вас есть повторяющийся *component* внутри модуля, тогда поиск может дать несколько результатов в пределах одного файла. Модуль, как правило, ограничен одим шаблоном.

## Поскольку повторное использование вызывает увеличение объема кода.

Попытки повторно использовать каждое отдельное *правило* порождают такие классы, как `red`, `clearfix`, `pull-left`, `grid`, что приводит к раздуванию HTML-кода:

	<div class="clearfix pull-left red etc">

Раздутый код труднее поддерживать и у него снижается производительность (хотя и незначительно).

## Поскольку повторное использование нарушает семантику.

Если вы стремитесь повторно использовать элементы внутри фигурных скобок, чтобы создать "атомарные" имена классов, то вы столкнетесь со всеми проблемами, изложенными в главе [Semantics](/chapters/semantics/). Прочитайте эту главу сейчас, если еще не успели.

## А если я действительно хочу использовать стиль повторно?

Очень редко, но случается, что имеет смысл использовать стиль повторно. Тогда используйте запятую в своих селекторах и помещайте их в файл с подходящим именем.

Например, вы хотите, чтобы набор разных модулей или компонентов использовал текст красного цвета. Это можно реализовать следующим образом:

	/* colours.css */

	/* red text */
	.someSelector,
	.someOtherSelector {
		color: red;
	}

Однако помните, что при изменении любого селектора, даже незначительном, его прийдется вынести из общего списка и определить отдельно. Нужно быть осторожным в подобной ситуации. Сделайте это из соображений удобства, а не производительности. Хотя это дело вкуса.

## А как быть с примесями?

CSS-препроцессоры позволяют создавать примеси, которые могут быть весьма полезны, т.к. дают возможность использовать лучшее из двух миров. Но создавать их нужно осмотрительно.

Вносить изменения в примеси нужно с большой осторожностью, т.к. они распространяются по всем экземплярам так же, как и вспомогательные классы. Трудности в редактировании примесей могут подтолкнуть вас к созданию новых, слегка измененных, что приводит к избыточности и сложности поддержки.

Кроме того, примеси могут становиться очень сложными, со множеством параметров, условиями и большими определениями стилей. Это также усложняет их поддержку.

В поисках выхода вы можете делать примеси более элементарными.
Например, получше выглядит примесь "красный текст". Но опять же, простое определение красного текста будет ничем не хуже определения такой примеси.

Если вам понадобится изменить его во многих местах, то поиск и замена с учетом контекста вполне справятся с этой задачей. Аналогично и в случае использования элементарной примеси, меняя красный на оранжевый, вам тоже придется осуществить поиск и замену, т.к. ставшее неактуальным имя примеси будет вводить в заблуждение.

Это не значит, что примеси непригодны&mdash;на самом деле они могут быть очень полезны. Например, возможность применить *clearfix* правила для различных элементов в различных контрольных точках, наверное, очень полезная вещь, облегчающая сопровождение. Просто пользутесь ими с осторожностью.

## А как на счет производительности?

У меня нет статистики под рукой, но я могу с уверенноcтью сказать, что неразумно практиковать преждевременную оптимизацию. Предположим, у вас есть очень большой объем CSS-кода (100Кб или больше).

Во-первых, *предположительно* вы *сможете* сэкономить себе несколько Кб. Во-вторых, существуют альтернативные пути  повышения производительности. И в-третьих, вероятно, у вас есть избыточный код из-за дефицита сопровождаемости.

Также учтите, что размер одной-двух картинок, вероятно, будет намного больше, чем весь CSS. Так что приложенные здесь усилия, скорее всего, не окупятся.

## Является ли это нарушением принципов DRY?

Попытка повторного использования `float: left`, например, сродни повторному использованию имени переменной в различных объектах Javascript. Это вовсе не противоречит DRY.

## В заключение

Повторное использование и DRY - это важные принципы разработки программного обеспечения, но в случае с CSS стремление широко применять повторное использование, как ни странно, *ухудшает* сопровождаемость. Тем не менее, иногда повторное использование и абстракции имеют смысл, вернемся к этому в последующих главах.
